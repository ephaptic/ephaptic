{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"ephaptic"},{"location":"#what-is-ephaptic","title":"What is <code>ephaptic</code>?","text":"ephaptic (adj.)     electrical conduction of a nerve impulse across an ephapse without the mediation of a neurotransmitter.  <p>Nah, just kidding. It's an RPC framework.</p> <p>ephaptic \u2014 Call your backend straight from your frontend. No JSON. Low latency. Invisible middleware.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p>Ephaptic is designed to be invisible. Write a function on the server, call it on the client. No extra boilerplate.</p> </li> <li> <p>Plus, it's horizontally scalable with Redis (optional), and features extremely low latency thanks to msgpack.</p> </li> <li> <p>Oh, and the client can also listen to events broadcasted by the server. No, like literally. You just need to add an <code>eventListener</code>. Did I mention? Events can be sent to specific targets, specific users - not just anyone online.</p> </li> <li> <p>Saved the best for last: it's type-safe. Don't believe me? Try it out for yourself. Simply type hint return values and parameters on the backend, and watch those very Python types transform into interfaces and types on the TypeScript frontend. Plus, you can use Pydantic - which means, for those of you who are FastAPI users, this is going to be great.</p> </li> </ul> <p>What are you waiting for? Let's go.</p> Python <pre><code>$ pip install ephaptic\n</code></pre> <pre><code>from fastapi import FastAPI # or `from quart import Quart`\nfrom ephaptic import Ephaptic\n\napp = FastAPI() # or `app = Quart(__name__)`\n\nephaptic = Ephaptic.from_app(app) # Finds which framework you're using, and creates an ephaptic server.\n</code></pre>  You can also specify a custom path:  <pre><code>ephaptic = Ephaptic.from_app(app, path=\"/websocket\")\n</code></pre>  And you can even use Redis for horizontal scaling!  <pre><code>ephaptic = Ephaptic.from_app(app, redis_url=\"redis://my-redis-container:6379/0\")\n</code></pre>  Now, how do you expose your function to the frontend?  <pre><code>@ephaptic.expose\nasync def add(num1: int, num2: int) -&gt; int:\n    return num1 + num2\n</code></pre> If you're trying to expose functions statelessly, e.g. in a different file, feel free to instead import and use the <code>expose</code> function from the library instead of the instance. Please note that if you do this, you must define all exposed functions before creating the ephaptic instance - easily done by simply placing your import line above the ephaptic constructor. The same thing can be done with the global <code>identity_loader</code> decorator.  Yep, it's really that simple.  But what if your code throws an error? No sweat, it just throws up on the frontend, with the error name.  And, want to say something to the frontend?  <pre><code>class Notification(BaseModel):\n    message: str\n    priority: Literal[\"high\", \"low\", \"default\"]\n\nawait ephaptic.to(user1, user2).emit(Notification(message=\"Hello, world!\", priority=\"high\"))\n</code></pre>  To create a schema of your RPC endpoints:  <pre><code>$ ephaptic generate src.app:app -o schema.json # --watch to run in background and auto-reload on file change.\n$ # Or:\n$ ephaptic generate src.app:app -o ephaptic.d.ts # converts directly to typescript\n</code></pre>  Pydantic is entirely supported. It's validated for arguments, it's auto-serialized when you return a pydantic model, and your models receive type definitions in the schema.  To receive authentication objects and handle them:  <pre><code>from ephaptic import identity_loader\n\n@identity_loader\nasync def load_identity(auth): # You can use synchronous functions here too.\n    jwt = auth.get(\"token\")\n    if not jwt: return None # unauthorized\n    ... # app logic to retrieve user ID\n    return user_id\n</code></pre>  From here, you can use <code>ephaptic.active_user()</code> within any exposed function, and it will give you the current active user ID / whatever else your identity loading function returns. (This is also how <code>ephaptic.to</code> works.)   JavaScript/TypeScript \u2014 Browser (Svelte, React, Angular, Vite, etc.) To use with a framework / Vite: <pre><code>$ npm install @ephaptic/client\n</code></pre>  Then:  <pre><code>import { connect } from \"@ephaptic/client\";\n\nconst client = connect(); // Defaults to `/_ephaptic`.\n</code></pre>  Or, you can use it with a custom URL:  <pre><code>const client = connect({ url: '/ws' });\n</code></pre> <pre><code>const client = connect({ url: 'wss://my-backend.deployment/ephaptic' });\n</code></pre>  You can even send auth objects to the server for identity loading.  <pre><code>const client = connect({ url: '...', auth: { token: window.localStorage.getItem('jwtToken') } })\n</code></pre>  And you can load types, too.  <pre><code>$ ephaptic from-schema ./schema.json -o schema.d.ts # --watch to auto-reload upon changes\n</code></pre> <pre><code>import { connect } from \"@ephaptic/client\";\nimport { type EphapticService } from './schema';\n\nconst client = connect(...) as unknown as EphapticService;\n</code></pre> Or, to use in your browser: <pre><code>&lt;script type=\"module\"&gt;\nimport { connect } from 'https://cdn.jsdelivr.net/npm/@ephaptic/client@latest/+esm';\n\nconst client = connect(...);\n&lt;/script&gt;\n</code></pre> <p>See more in the docs.</p>"},{"location":"#license","title":"License","text":"<p>     \u00a9 ephaptic 2025 </p>"},{"location":"diagram/","title":"Redis Diagram","text":"<pre><code>sequenceDiagram\n    autonumber\n    actor A as User A (Browser)\n    participant N4 as Node 4\n    participant R as Redis\n    participant N0 as (... Nodes 1-30 ...)\n    participant N18 as Node 18\n    actor B as User B (Browser)\n\n    Note over A, N4: Connected via WebSocket\n    Note over B, N18: Connected via WebSocket\n\n    A-&gt;&gt;N4: Sends \"Hi!\"\n    Note over N4: Checks local connections...\n    Note over N4: User B not found\n\n    N4-&gt;&gt;R: PUBLISH \"Event for User B\"\n\n    par Redis Broadcasts to All Nodes\n        R-&gt;&gt;N4: \"Event for User B\"\n        Note over N4: Ignores (User B not connected)\n        R-&gt;&gt;N18: \"Event for User B\"\n        Note over N18: Checks local connections...&lt;br/&gt;(User B Found!)\n        N18-&gt;&gt;B: Pushes \"Hi!\" Event\n        R--&gt;&gt;N0: (Other nodes receive it too)\n        Note over N0: Ignores (User B not connected)\n    end</code></pre> <p>Imagine you have a chat app in production, with 30 nodes (servers), and a load balancer.</p> <p>Each of your 30 nodes run their own instance of the backend, and you have a load balancer.</p> <p>Now, imagine you have two users, User A and User B, who are in a DM with each other.</p> <p>User A loads your chat app in their browser. A WebSocket connection is established between User A and a random available node (picked by the load balancer) - in this case, Node 4. User A sends a message: \"Hi!\".</p> <p>The message travels from User A's browser, through the websocket, to Node 4.</p> <p>Node 4 then receives the message and stores it in the database. However, it also emits an event to User B.</p> <p>Node 4 checks all the users connected to it, and checks if User B is connected. Now, 29 times out of 30, User B will be connected to a different node than User A. And in this case, User B is actually connected to Node 18. But Node 4 doesn't know that. So Node 4 uses the Redis Pub/Sub mechanism to publish an event: \"Send this  to &lt;User B&gt;\". <p>Once this event has been sent, all 30 of your nodes receive the message. All 30 of them check whether User B is connected to them or not. Most of them see User B is not connected, and ignore the message. But Node 18 sees User B connected. So, Node 18 finds the connected websocket to User B, and broadcasts the . <p>User B's browser picks up the event, and displays the message sent. This all happens in under a second (and the largest part of the delay is the IO between User A and User B's network, not Redis).</p> <p>Now, scale this to User B being logged in on their phone, tablet, and laptop. The phone is connected to Node 4, the tablet to Node 9, and the laptop to Node 18.</p> <p>When User A sends another message, Node 4 immediately picks up the User B connected to its own node, and broadcasts the message to the phone. It then broadcasts the message via Redis, and Nodes 9 &amp; 18 receive the message (the others ignore it). From here, Nodes 9 &amp; 18 both see they have an active connection to User B, and broadcast the message. Now, User B's tablet and laptop also receive the message instantly.</p> <p>What about a group chat? Imagine Users C and D join. When User A sends a message, the backend now sends the  to &lt;User B &amp; User C &amp; User D&gt;. The flow is the same. The message gets sent out via Redis, and this time the servers check if they have B, C, or D connected. If so, they send the event over the transport."},{"location":"advanced/cli/","title":"The CLI","text":"<p>The CLI is accessed by running <code>ephaptic</code> in your terminal.</p> <p>If it doesn't work, you may need to run <code>.venv/bin/ephaptic</code> or <code>~/.local/bin/ephaptic</code>. Consider adding these to PATH.</p>"},{"location":"advanced/cli/#ephaptic","title":"ephaptic","text":"<p>Ephaptic CLI tool.</p> <p>Usage:</p> <pre><code>ephaptic [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n  --help                Show this message and exit.\n</code></pre>"},{"location":"advanced/cli/#from-schema","title":"from-schema","text":"<p>Usage:</p> <pre><code>ephaptic from-schema [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --schema-path PATH       Path to the schema file.  [default: schema.json]\n  -o, --output PATH        Output path for the generated file (default:\n                           ephaptic.d.ts / Ephaptic.kt).\n  -w, --watch              Watch for changes in `.py` files and regenerate\n                           schema file automatically.\n  -l, --lang TEXT          Output language ('kotlin', 'kt', 'typescript',\n                           'ts') (default: autodetected from output path)\n  -p, --package-name TEXT  Package name (required for Kotlin)  [default:\n                           com.example.app]\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"advanced/cli/#generate","title":"generate","text":"<p>Usage:</p> <pre><code>ephaptic generate [OPTIONS] [CLIENT]\n</code></pre> <p>Options:</p> <pre><code>  [CLIENT]                 The import string for the Ephaptic client.\n                           [default: app:client]\n  -o, --output PATH        Output path for the generated file (default:\n                           schema.json / ephaptic.d.ts / Ephaptic.kt).\n  -w, --watch              Watch for changes in `.py` files and regenerate\n                           schema file automatically.\n  -l, --lang TEXT          Output language ('json', 'kotlin', 'kt',\n                           'typescript', 'ts') (default: autodetected from\n                           output path)\n  -p, --package-name TEXT  Package name (required for Kotlin)  [default:\n                           com.example.app]\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"advanced/deployment/","title":"Deployment","text":"<p>If you're going to production, you obviously can't connect to <code>localhost:8000</code> on your site.</p> <p>You'll need to connect to the backend part of your site, from the frontend.</p> <p>But how? Let's show you.</p>"},{"location":"advanced/deployment/#docker","title":"Docker","text":"<p>For this tutorial, we'll be using Docker containers named <code>frontend</code>, <code>backend</code>, and <code>gateway</code>.</p> <p>First, set up your file structure.</p> <pre><code>\u251c\u2500\u2500 backend\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 frontend\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 gateway\n\u2502    \u2514\u2500\u2500 nginx.conf\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 .dockerignore\n</code></pre> <p>Now, let's create the <code>docker-compose.yml</code> file.</p> docker-compose.yml<pre><code>services:\n  backend:\n    build: ./backend\n    expose:\n      - \"8000\"\n    networks:\n      - internal\n    restart: unless-stopped\n\n  frontend:\n    build: ./frontend\n    depends_on:\n      - backend\n    expose:\n      - \"3000\"\n    environment:\n      - NODE_ENV=production\n    networks:\n      - internal\n    restart: unless-stopped\n\n  gateway:\n    image: nginx:alpine\n    depends_on:\n      - frontend\n      - backend\n    volumes:\n      # Mount the `gateway/nginx.conf` into the container.\n      - ./gateway/nginx.conf:/etc/nginx/conf.d/default.conf\n    networks:\n      - internal\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    restart: unless-stopped\n\nnetworks:\n  internal:\n    driver: bridge\n</code></pre> <p>Next, we need to create <code>gateway/nginx.conf</code>.</p> nginx.conf<pre><code>server {\n    listen 80;\n\n    location / {\n        proxy_pass http://frontend:3000;\n\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        proxy_read_timeout 300s;\n    }\n\n    location /_ephaptic {\n        proxy_pass http://backend:8000/_ephaptic;\n        proxy_http_version 1.1;\n\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        proxy_buffering off;\n\n        proxy_read_timeout 3600s;\n        proxy_send_timeout 3600s;\n        proxy_connect_timeout 60s;\n    }\n\n    gzip on;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss;\n}\n</code></pre> <p>Now, run <code>docker compose up --build</code> and head to localhost:80 in your browser.</p> <p>Tip</p> <p>Make sure we remove the <code>url</code> parameter in the ephaptic constructor, as now it automatically defaults to <code>/_ephaptic</code> on the same host.</p> <p>Congrats! We've got a production-ready ephaptic working!</p> <p>Well, not fully yet. We still need Redis for horizontal scaling (multiple workers), if you are using the identity loading feature.</p>"},{"location":"advanced/deployment/#redis","title":"Redis","text":"<p>Let's modify <code>backend/src/app.py</code>:</p> backend/src/app.py<pre><code>import os\n\nephaptic = Ephaptic.from_app(app, redis_url=os.getenv(\"REDIS_URL_BASE\")+\"/0\")\n</code></pre> <p>Now, we need to pass the base redis url to the backend container, and also create a <code>redis</code> container in Docker.</p> docker-compose.yml<pre><code>services:\n  backend:\n    build: ./backend\n    depends_on:\n      redis\n    environment:\n      REDIS_URL_BASE: \"redis://redis:6379\"\n    expose:\n      - \"8000\"\n    networks:\n      - internal\n    restart: unless-stopped\n\n  frontend:\n    ...\n\n  gateway:\n    ...\n\n  redis:\n    image: redis:alpine\n    expose:\n      - \"6379\"\n    volumes:\n      - redis-data:/data\n    networks:\n      - internal\n    restart: unless-stopped\n\nnetworks:\n  ...\n\nvolumes:\n  redis-data:\n</code></pre> <p>Now, rerun the app.</p> <pre><code>$ docker compose up --build\n</code></pre> <p>You may not notice anything, but now, each <code>uvicorn</code> worker knows which clients that they have connected, and they're able to talk to each other.</p> <p>This means, even in a distributed system with hundreds of nodes running the backend container, if they're all hooked up to one Redis instance, an event emitted by one node (<code>await ephaptic.to(user).emit(event)</code>) will always reach the node that the target user is connected to, which will then broadcast it to the frontend.</p> <p>Info</p> <p>For more information on why this is required, and how it works, head to the diagram.</p>"},{"location":"advanced/tanstack/","title":"TanStack Query Integration","text":"<p>For those of you who have used tRPC before, you might be familiar with TanStack Query.</p> <p>Luckily for you, ephaptic has first-class support for it.</p> <p>Let's use it.</p> ReactSvelte <pre><code>import { connect } from '@ephaptic/client';\nimport type { EphapticService } from './schema';\nimport { useQuery } from '@tanstack/react-query';\n\nconst client = connect() as unknown as EphapticService;\n\nfunction Todos() {\n    const { data, isPending, error } = useQuery(client.queries.getTodos()); // You can also pass arguments, the same way you normally would.\n\n    if (isPending) return &lt;span&gt;Loading...&lt;/span&gt;;\n    if (error) return &lt;span&gt;Oops!&lt;/span&gt;;\n\n    return &lt;ul&gt;{data.map(t =&gt; &lt;li key={t.id}&gt;{t.title}&lt;/li&gt;)}&lt;/ul&gt;;\n}\n\nexport default Todos;\n</code></pre> <pre><code>&lt;script lang=\"ts\"&gt;\n    import { connect } from '@ephaptic/client';\n    import type { EphapticService } from '$lib/schema';\n    import { createQuery } from '@tanstack/svelte-query';\n\n    const client = connect() as unknown as EphapticService;\n\n    // NOTE: Svelte Query v5 requires you to pass a function first, for reactivity.\n    const todos = createQuery(() =&gt; { client.queries.getTodos() }); // You can also pass arguments, the same way you normally would.\n&lt;/script&gt;\n\n{#if $todos.isPending}\n    Loading...\n{:else if $todos.error}\n    Oops!\n{:else}\n    &lt;ul&gt;\n        {#each $todos.data as t}\n            &lt;li&gt;{t.title}&lt;/li&gt;\n        {/each}\n    &lt;/ul&gt;\n{/if}\n</code></pre> <p>Note</p> <p>Both of these examples were taken from the official TanStack Query page for the respective frameworks, and then modified.</p>"},{"location":"tutorial/","title":"Intro","text":"<p>Hi! Glad to see you've chosen ephaptic.</p> <p>Head over to the first steps to get started.</p>"},{"location":"tutorial/events/","title":"Events","text":"<p>Now that we know how to call functions from the backend on the frontend, let's try something somewhat reversed: sending data from the backend to the frontend.</p> <p>Okay, so first, let's define the event that we want to send.</p> <p>Tip</p> <p>Keep your current imports the same, just add these extras if necessary. Don't replace your code, add to it!</p> backend/src/app.py<pre><code>from pydantic import BaseModel\n\n...\n\n@ephaptic.event\nclass SomethingHappened(BaseModel): # (1)\n    code: int = 1\n    message: str\n    isError: bool = False\n\n# Now, broadcast the event.\n\n@ephaptic.expose\nasync def broadcastEvent(event: SomethingHappened) -&gt; None:\n    await ephaptic.emit(event)\n</code></pre> <ol> <li>As you would know from Parameters &amp; Pydantic, there are lots of fields you can put in here.</li> </ol> <p>We can also use the identity loading feature to broadcast to specific user(s):</p> <pre><code>await ephaptic.to(1).emit(event) # (1)\n</code></pre> <ol> <li>Here, <code>1</code> is the user ID that we want to emit to. You can provide a list, or a group of args. Ex. <code>.to(1, 2, 3)</code>, or <code>.to([1, 2, 3])</code></li> </ol> <p>But what does this do?</p> <p>Well, since ephaptic allows you to use Pydantic models as function inputs, on the TypeScript end, you can simply call:</p> <pre><code>await client.broadcastEvent({ message: \"John created an account!\" });\n</code></pre> <p>And you'll receive full TypeScript safety (autocomplete, missing parameters, etc.) on the event parameter.</p> <p>Now, how do we receive the event?</p> <p>It's simple!</p> <pre><code>client.on('SomethingHappened', data =&gt; {\n    console.log(data.message);\n})\n</code></pre> <p>Notice that as soon as you type <code>client.on('</code>, the autocomplete knows that the only event registered, and therefore the only thing you can type, is <code>SomethingHappened</code>, so if you press <code>TAB</code> it fills in the event name for you. Additionally, the <code>data</code> is now of type <code>SomethingHappened</code> (again, if you wish, you can import it from the schema).</p> <p>For a proper demonstration with your framework of choice, you should use lifecycle hooks to clean up the listener when the component unmounts.</p> ReactSvelte frontend/src/App.tsx<pre><code>import { useEffect } from \"react\";\nimport type { SomethingHappened } from './schema';\n\nfunction App() {\n    useEffect(() =&gt; {\n        const handleEvent = (data: SomethingHappened) =&gt; {\n            console.log(data.message);\n        };\n\n        client.on('SomethingHappened', handleEvent);\n\n        return () =&gt; {\n            client.off('SomethingHappened', handleEvent);\n        };\n    }, []);\n\n    return &lt;h1&gt;Listening for events...&lt;/h1&gt;;\n}\n</code></pre> src/routes/+page.svelte<pre><code>&lt;script lang=\"ts\"&gt;\n    import { onMount } from 'svelte';\n    import type { SomethingHappened } from './schema';\n\n    onMount(() =&gt; {\n        const handleEvent = (data: SomethingHappened) =&gt; {\n            console.log(data.message);\n        };\n\n        client.on('SomethingHappened', handleEvent);\n\n        return () =&gt; {\n            client.off('SomethingHappened', handleEvent);\n        };\n    });\n&lt;/script&gt;\n\n&lt;h1&gt;Listening for events...&lt;/h1&gt;\n</code></pre>"},{"location":"tutorial/first-steps/","title":"First Steps","text":"<p>Let's build a simple app.</p> <p>We'll create a function on the backend that adds two numbers together, and then call it on the frontend.</p>"},{"location":"tutorial/first-steps/#the-backend","title":"The Backend","text":"<p>Let's create the FastAPI backend.</p> <p>Run this in your project directory:</p> <pre><code>$ mkdir -p backend/src\n$ echo \"ephaptic\" &gt; backend/requirements.txt\n$ echo \"fastapi[standard]\" &gt;&gt; backend/requirements.txt\n$ python -m venv backend/.venv\n$ source backend/.venv/bin/activate\n$ pip install -r backend/requirements.txt\n</code></pre>  Now, create `backend/src/app.py` in your favourite editor.   backend/src/app.py<pre><code>from fastapi import FastAPI\nfrom ephaptic import Ephaptic\n\napp = FastAPI()\nephaptic = Ephaptic.from_app(app)\n\n# Use the decorator to expose the function to the frontend!\n@ephaptic.expose\nasync def add(a: int, b: int) -&gt; int: # Type hint our function!\n    return a + b\n</code></pre> <p>That's literally it. No routes, no REST methods, no JSON parsing, no boilerplate that you're used to.</p>"},{"location":"tutorial/first-steps/#generate-the-schema","title":"Generate the Schema","text":"<p>Now, we need to tell the frontend about our new code. Run this in your terminal:</p> <pre><code>$ ephaptic generate backend.src.app:ephaptic -o schema.json --watch # You can also output directly as .d.ts, skipping the JSON schema layer.\n\nWatching for changes (/home/user/ephaptic-demo/)...\nAttempting to import `ephaptic` from `backend.src.app` ...\nFound 1 functions.\n  - add\nSchema generated to `schema.json`.\n</code></pre> <p>For more info about the CLI, head to The CLI.</p>"},{"location":"tutorial/first-steps/#the-frontend","title":"The Frontend","text":"<p>Now, let's build the frontend app that will run this.</p> <p>Tip</p> <p>ephaptic is framework independent. You don't have to use React or Svelte - any framework/library will work! You can even do it in native JS with the CDN: <pre><code>&lt;script type=\"module\"&gt;\n    import { connect } from 'https://cdn.jsdelivr.net/npm/@ephaptic/client/+esm';\n\n    const client = connect();\n&lt;/script&gt;\n</code></pre> Just be aware that if you opt for native browser JS, you won't receive type support (JavaScript does not support types.)</p> ReactSvelte <pre><code>$ npm create vite@latest frontend\nNeed to install the following packages:\ncreate-vite@8.2.0\nOk to proceed? (y) \n\n\n&gt; npx\n&gt; \"create-vite\" frontend\n\n\u2502\n\u25c7  Select a framework:\n\u2502  React\n\u2502\n\u25c7  Select a variant:\n\u2502  TypeScript\n\u2502\n\u25c7  Use rolldown-vite (Experimental)?:\n\u2502  No\n\u2502\n\u25c7  Install with npm and start now?\n\u2502  Yes\n\u2502\n\u25c7  Scaffolding project in /home/user/ephaptic-demo/frontend...\n\u2502\n\u25c7  Installing dependencies with npm...\n\nadded 175 packages, and audited 176 packages in 26s\n\n45 packages are looking for funding\nrun `npm fund` for details\n\nfound 0 vulnerabilities\n\u2502\n\u25c7  Starting dev server...\n\n&gt; frontend@0.0.0 dev\n&gt; vite\n\nVITE v7.3.0  ready in 172 ms\n\n\u279c  Local:   http://localhost:5173/\n\u279c  Network: use --host to expose\n\u279c  press h + enter to show help\n^C\n\n$ cd frontend\n$ npm i\n$ npm i @ephaptic/client\n</code></pre> <pre><code>$ mkdir frontend\n$ cd frontend\n$ npx sv create\nNeed to install the following packages:\nsv@0.11.0\nOk to proceed? (y) \n\n\n\u250c  Welcome to the Svelte CLI! (v0.11.0)\n\u2502\n\u25c7  Where would you like your project to be created?\n\u2502  ./\n\u2502\n\u25c7  Which template would you like?\n\u2502  SvelteKit minimal\n\u2502\n\u25c7  Add type checking with TypeScript?\n\u2502  Yes, using TypeScript syntax\n\u2502\n\u25c7  What would you like to add to your project? (use arrow keys / space bar)\n\u2502  none\n\u2502\n\u25c6  Project created\n\u2502\n\u25c7  Which package manager do you want to install dependencies with?\n\u2502  npm\n\u2502\n\u2502  npx sv create --template minimal --types ts --install npm ./\n\u2502\n\u2502\n\u25c6  Successfully installed dependencies with npm\n\u2502\n\u25c7  What's next? \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                              \u2502\n\u2502  \ud83d\udcc1 Project steps                            \u2502\n\u2502                                              \u2502\n\u2502    1: npm run dev -- --open                  \u2502\n\u2502                                              \u2502\n\u2502  To close the dev server, hit Ctrl-C         \u2502\n\u2502                                              \u2502\n\u2502  Stuck? Visit us at https://svelte.dev/chat  \u2502\n\u2502                                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u2502\n\u2514  You're all set!\n$ npm i @ephaptic/client\n</code></pre> <p>We'll generate the TypeScript definitions and then use them.</p> ReactSvelte <pre><code>$ ephaptic from-schema ../schema.json -o ./src/schema.d.ts\nWatching for changes (../schema.json)...\nSchema generated to `./src/schema.d.ts`.\n</code></pre> <pre><code>$ ephaptic from-schema ../schema.json -o ./src/lib/schema.d.ts\nWatching for changes (../schema.json)...\nSchema generated to `./src/lib/schema.d.ts`.\n</code></pre> <p>Now, we can finally use the client.</p> ReactSvelte frontend/src/App.tsx<pre><code>import { connect } from \"@ephaptic/client\";\nimport { type EphapticService } from \"./schema\";\nimport { useEffect } from \"react\";\n\nconst client = connect({\n    url: \"ws://localhost:8000/_ephaptic\"\n}) as unknown as EphapticService;\n\nfunction App() {\n    useEffect(() =&gt; {\n        async function calculate() {\n            const num1 = 2;\n            const num2 = 3;\n            const result = await client.add(num1, num2);\n            console.log(result);\n        }\n\n        calculate();\n    }, []);\n\n    return &lt;h1&gt;Check the console!&lt;/h1&gt;;\n}\n\nexport default App;\n</code></pre> frontend/src/routes/+page.svelte<pre><code>&lt;script lang=\"ts\"&gt;\n    import { connect } from \"@ephaptic/client\";\n    import { type EphapticService } from \"$lib/schema\";\n    import { onMount } from 'svelte';\n\n    const client = connect({\n        url: \"ws://localhost:8000/_ephaptic\"\n    }) as unknown as EphapticService;\n\n    onMount(async () =&gt; {\n        const num1 = 2;\n        const num2 = 3;\n\n        const result = await client.add(num1, num2);\n\n        console.log(result);\n    });\n&lt;/script&gt;\n\n&lt;h1&gt;Check the console!&lt;/h1&gt;\n</code></pre> <p>Going to Production?</p> <p>In development, we hardcoded <code>ws://localhost:8000</code> because the frontend (port 5173) and backend (port 8000) are separate.</p> <p>In production (e.g., Docker), you should use a Reverse Proxy (like Nginx or Traefik) to route traffic.</p> <ul> <li>Route <code>/</code> -&gt; Frontend Container</li> <li>Route <code>/_ephaptic</code> -&gt; Backend Container</li> </ul> <p>This allows you to revert to <code>const client = connect();</code> (without arguments), as the browser will correctly infer the host and port relative to the current page.</p> <p>Alternatively, if your backend and your frontend are on different hosts, you can specify it: <code>connect({ url: 'wss://my-backend.app/_ephaptic' })</code>.</p> <p>Learn more in the Deployment section.</p> <p>Tip</p> <p>Notice that if you try to pass a string like <code>client.add(\"2\", 3)</code>, your editor will scream at you. That's the power of ephaptic. We'll learn more about this in the next chapter.</p>"},{"location":"tutorial/first-steps/#run-the-app","title":"Run the app","text":"<p>Now that we've added all the code, let's fire everything up! You'll need to have two terminals open to run these commands.</p> <pre><code>$ # Make sure you are in the .venv\n$ source backend/.venv/bin/activate\n$ uvicorn backend.src.app:app --reload --port 8000\nINFO:     Will watch for changes in these directories: ['/home/user/ephaptic-demo']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [1] using WatchFiles\nINFO:     Started server process [2]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <pre><code>$ cd frontend\n$ npm run dev\n\n&gt; frontend@0.0.1 dev\n&gt; vite dev\n\n12:00:00 [vite] (client) Forced re-optimization of dependencies\n\n  VITE v7.3.0  ready in 1000 ms\n\n  \u279c  Local:   http://localhost:5173/\n  \u279c  Network: use --host to expose\n  \u279c  press h + enter to show help\n</code></pre> <p>Now, open http://localhost:5173 in your browser. Check the console (<code>F12</code>). You should see the result of the addition logged!</p> <p>Congratulations!</p> <p>Well done! We've just built a full-stack, low-latency, type-safe app without writing a single API route or serializers!</p>"},{"location":"tutorial/parameters/","title":"Parameters &amp; Pydantic","text":""},{"location":"tutorial/parameters/#type-safety","title":"Type Safety","text":"<p>In first steps, we built our first RPC app. The app had functionality to add two numbers.</p> <p>Do you remember the type hinting?</p> <pre><code>async def add(a: int, b: int) -&gt; int:\n</code></pre> <p>By using these types, we tell TypeScript:</p> <ol> <li>The first argument is named <code>a</code> and must be a <code>number</code> type, and is required.</li> <li>The second argument is named <code>b</code> and must be a <code>number</code> type, and is required.</li> <li>The function returns a type <code>number</code>.</li> </ol> <p>You can see this by hovering over the <code>add</code> function in your IDE:</p> <p><code>(method) EphapticService.add(a: number, b: number): Promise&lt;number&gt;</code></p> <p>If we had done <code>await client.add(\"2\", \"3\");</code> in TypeScript, we would get an error:</p> <p>Argument of type 'string' is not assignable to parameter of type 'number'.</p> <p>This is called type-safety.</p>"},{"location":"tutorial/parameters/#parameters","title":"Parameters","text":"<p>Let's try changing the type hints in Python.</p> <pre><code>from typing import Optional\n\nasync def add(a: int, b: Optional[int]) -&gt; int:\n    return a + b if b else a\n</code></pre> <p>Look what happens. Instantly. Hover over the <code>add</code> function in your IDE, and you'll see this:</p> <p><code>(method) EphapticService.add(a: number, b: number | null): Promise&lt;number&gt;</code></p> <p>Tip</p> <p>If you don't see anything, make sure both the type-generation commands from earlier, with the <code>--watch</code> flag. If you still don't see anything, make sure your TypeScript-enabled (e.g. Intellisense) extension is enabled. We recommend VSCode for this.</p> <p>What did we change on the TypeScript side? Nothing! But now, the second <code>b</code> parameter has the <code>number | null</code> type.</p> <p>What does this mean? Well, try this:</p> <pre><code>await client.add(num1, null);\n</code></pre> <p>Since we've now stated that the second number is allowed to be nothing, we can safely pass <code>null</code> through. And, if you try running this, you'll see simply the first number (<code>2</code>) logged to your browser.</p>"},{"location":"tutorial/parameters/#pydantic","title":"Pydantic","text":"<p>This is cool, but imagine a real-world app. You have a database, with models for various things - for example, users!</p> <p>Let's imagine here's your user model.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    username: str\n    email: Optional[str] = None\n</code></pre> <p>Now, let's say we have a function to retrieve a user.</p> <p>Tip</p> <p>In Authentication, we cover retrieving the currently logged in user in more detail. For now, let's assume the current user is the first one in the database.</p> <pre><code>class User(...):\n    ...\n\ndatabase = {} # Obviously, in a real app, you'd have a real database here.\ndatabase[\"users\"] = [User(id=1, username=\"admin\", email=None)]\n\n@ephaptic.expose\nasync def get_user() -&gt; User: # Notice we've type-hinted our return value: `User`.\n    return database[\"users\"][0]\n</code></pre> <p>Now, how would we access the user on the frontend?</p> <pre><code>const user = await client.get_user();\n</code></pre> <p>If you hover over the <code>get_user</code> function, you'll see the method signature:</p> <p><code>(method) EphapticService.get_user(): Promise&lt;User&gt;</code></p> <p>The function returns a User object. Even the name <code>User</code> has synced across languages!</p> <p>Now, hover over the <code>user</code> variable.</p> <p>const user: User</p> <p>Let's try to display information about the user.</p> ReactSvelte <pre><code>return (\n    &lt;div className=\"user-view\"&gt;\n        &lt;h2&gt;{user.username}&lt;/h2&gt;\n        &lt;small&gt;{user.email}&lt;/small&gt;\n    &lt;/div&gt;\n);\n</code></pre> <pre><code>&lt;div class=\"user-view\"&gt;\n    &lt;h2&gt;{user.username}&lt;/h2&gt;\n    &lt;small&gt;{user.email}&lt;/small&gt;\n&lt;/div&gt;\n</code></pre> <p>There's a problem, though. If you hover the <code>user</code> here, you'll spot an error:</p> <p>Cannot find name 'user'.</p> <p>Additionally, you won't receive autocomplete when typing out user properties, because TypeScript doesn't know what you mean by <code>user</code>.</p> <p>This is because the <code>user</code> is being defined still in our <code>onMount</code> function, but it's not a global variable.</p> <p>Let's define it globally.</p> ReactSvelte <pre><code>import { useState, useEffect } from \"react\";\n// We can import the `User` type from the schema with the same name as our model.\nimport type { EphapticService, User } from \"./schema\";\n\nfunction App() {\n    const [user, setUser] = useState&lt;User | null&gt;(null);\n\n    useEffect(() =&gt; {\n        async function load() {\n            const data = await client.get_user();\n            setUser(data);\n        }\n        load();\n    }, []);\n}\n</code></pre> <pre><code>// We can import the `User` type from the schema with the same name as our model.\nimport type { EphapticService, User } from \"$lib/schema\";\n\nlet user: User | null = null;\n\nonMount(async () =&gt; {\n    user = await client.get_user();\n});\n</code></pre> <p>But, the HTML snippet remains underlined in red? Let's check the new error.</p> <p>'user' is possibly 'null'.</p> <p>This is because we defined the type as <code>User | null</code>.</p> <p>To fix this, let's render conditionally, and also add a loading message.</p> ReactSvelte <pre><code>if (!user) return (&lt;p&gt;Loading...&lt;/p&gt;)\nreturn (\n    &lt;div className=\"user-view\"&gt;\n        &lt;h2&gt;{user.username}&lt;/h2&gt;\n        &lt;small&gt;{user.email || \"No email set.\"}&lt;/small&gt;\n    &lt;/div&gt;\n);\n</code></pre> <pre><code>{#if !user}\n    &lt;p&gt;Loading...&lt;/p&gt;\n{:else}\n    &lt;div class=\"user-view\"&gt;\n        &lt;h2&gt;{user.username}&lt;/h2&gt;\n        &lt;small&gt;{user.email || \"No email set.\"}&lt;/small&gt;\n    &lt;/div&gt;\n{/if}\n</code></pre> <p>Tip</p> <p>You may also wish to use a proper state handler, like TanStack Query, to clean up this process. We have first-class support for TanStack Query. See the advanced section for details.</p>"},{"location":"tutorial/router/","title":"The Router","text":"<p>The Router is a FastAPI-specific way to expose your API routes both to an Ephaptic client, and to HTTP clients.</p>"},{"location":"tutorial/router/#features","title":"Features","text":"<p>It comes with the following benefits:</p> <ul> <li>You can <code>app.include_router(router)</code> with an Ephaptic Router the same way you can with a FastAPI APIRouter.</li> <li>Since both FastAPI and Ephaptic share the same Pydantic validation strategy, you can type-hint the function arguments and response model and both FastAPI and Ephaptic will handle it properly.<ul> <li>Ephaptic will return your Pydantic model or primitive type or a combination of both as a TypeScript interface on the client (or whatever other Ephaptic client you use), while FastAPI will return it JSON-serialized for your other clients.</li> </ul> </li> <li>Functions exposed via the Router will show up in the FastAPI-generated <code>openapi.json</code>, meaning Ephaptic routes will even show up, fully typed, in your Swagger UI.</li> <li>You only need to define your identity loader (ephaptic) and your http identity loader (you are passed a <code>fastapi.Request</code> object as context) once, then they are both selectively used and stored as the <code>active_user()</code>.</li> <li>For specific logic, you can use <code>ephaptic.ctx.is_http()</code> and <code>ephaptic.ctx.is_rpc()</code> within your functions. Instead of defining two almost duplicated functions for RPC-specific and HTTP-specific logic, you can put them under one function and then use these in an if-statement to branch out your logic.</li> </ul> <p>But how do you use it?</p>"},{"location":"tutorial/router/#usage","title":"Usage","text":""},{"location":"tutorial/router/#http-identity-loader","title":"HTTP Identity Loader","text":"<p>Info</p> <p>The <code>http_identity_loader</code> is just like the other decorators. You can call it from the global import (<code>from ephaptic import http_identity_loader</code>) or you can use <code>@ephaptic.http_identity_loader</code> where <code>ephaptic</code> is your Ephaptic instance.</p> <pre><code>from fastapi import FastAPI, Request\nfrom ephaptic import Ephaptic, active_user\nfrom ephaptic.ctx import is_http, is_rpc\nfrom ephaptic.ext.fastapi import Router\nimport pydantic\n\napp = FastAPI()\nephaptic = ephaptic.from_app(app)\n\n@ephaptic.identity_loader\ndef load_user(auth: str):\n    return auth # Obviously, in real life, you'd use a real authentication solution, like JWTs.\n\n@ephaptic.http_identity_loader\ndef load_user_http(request: Request):\n    auth = request.headers.get('Authorization')\n    if not auth: return None\n    return auth.removeprefix('Bearer ')\n\nrouter = Router(ephaptic)\n\nclass EchoResult(pydantic.BaseModel):\n    is_rpc: bool\n    is_http: bool\n    active_user: str\n    message: str\n\n@router.get('/echo', requires_login=True) # requires_login means the result of load_user must NOT be None.\ndef echo(message: str) -&gt; EchoResult:\n    return EchoResult(\n        is_rpc=is_rpc(),\n        is_http=is_http(),\n        active_user=active_user(),\n        message=message,\n    )\n\napp.include_router(router)\n</code></pre> <p>Now, you can run this app, and send both authenticated and unauthenticated requests via a HTTP client and an Ephaptic client, and verify they work as intended. You can even go to <code>/docs</code> and see the echo function there!</p>"},{"location":"tutorial/security/","title":"Authentication","text":"<p>We've covered a lot so far, but we still don't know who is sending these requests.</p> <p>To solve this, let's use a simple login system with JWTs.</p> <p>First, let's make sure the JWT library is installed on the backend.</p> <pre><code>$ # Make sure you are in the venv.\n$ echo \"pyjwt\" &gt;&gt; backend/requirements.txt\n$ pip install -r backend/requirements.txt\n</code></pre> <p>Now, we can edit the backend file.</p> backend/src/app.py<pre><code>from ephaptic import Ephaptic, identity_loader, active_user\nfrom datetime import datetime, timezone, timedelta\nimport jwt\nimport random, string\n\nJWT_SECRET = ''.join(random.choices(string.ascii_letters+string.digits, k=32)) # We would use an actual JWT secret in a `.env` in production!\n\ndef generate_token(user_id):\n    payload = {\n        'sub': user_id,\n        'exp': datetime.now(timezone.utc) + timedelta(weeks=52)\n    }\n    return jwt.encode(payload, JWT_SECRET, algorithm='HS256')\n\ndef verify_token(token):\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=['HS256'])\n        return payload['sub']\n    except:\n        return None\n\n@identity_loader # This decorator tells ephaptic the function we are using to load identity, from the auth payload.\ndef load_identity(auth):\n    token = auth.get(\"_jwt\")\n    if token:\n        return verify_token(token)\n    return None\n\n@ephaptic.expose\nasync def login(username: str) -&gt; str: # Expose a login function that returns a JWT.\n    # In a real app, we would check a database and hash passwords, but for demonstration purposes, we'll only require the username to log in.\n    if username == \"admin\":\n        # Assume the `admin` user has an ID of `1`.\n        return generate_token(1)\n\n    raise Exception(\"Invalid username\")\n\n@ephaptic.expose\nasync def get_user() -&gt; str:\n    return active_user()\n</code></pre> <p>Now, on the frontend, we can do this:</p> <pre><code>const client = connect({ auth: { _jwt: window.localStorage.getItem('token') } }) as unknown as EphapticService;\n</code></pre> <p>But we haven't got a way to set the token in localStorage yet.</p> <p>So, let's add login handling to the frontend.</p> ReactSvelte frontend/src/App.tsx<pre><code>const token = localStorage.getItem('token');\n\nconst client = connect({\n    url: \"ws://localhost:8000/_ephaptic\",\n    auth: { _jwt: token }\n}) as unknown as EphapticService;\n\nfunction App() {\n    const [user, setUser] = useState&lt;string | null&gt;(null);\n\n    useEffect(() =&gt; {\n        if (token) {\n            client.get_user()\n                .then(setUser)\n                .catch(() =&gt; {\n                    console.warn(\"Invalid token.\")\n                    localStorage.removeItem('token');\n                });\n        }\n    }, []);\n\n    const handleLogin = async () =&gt; {\n        const newToken = await client.login(\"admin\"); // In a real app, we'd have a login form with username and password inputs.\n\n        localStorage.setItem('token', newToken);\n        window.location.reload(); // Reloading the page re-connects the client with the new auth token.\n    };\n\n    const handleLogout = () =&gt; {\n        localStorage.removeItem('token');\n        window.location.reload();\n    }\n\n    if (!token) return &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;;\n    else return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome, {user}&lt;/h1&gt;\n            &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> src/routes/+page.svelte<pre><code>&lt;script lang=\"ts\"&gt;\n    // Making sure the code only runs in the browser, and not SSR.\n    const token = typeof window !== 'undefined' ? localStorage.getItem('token') : null;\n\n    const client = connect({\n        url: \"ws://localhost:8000/_ephaptic\",\n        auth: { _jwt: token }\n    }) as unknown as EphapticService;\n\n    let user = $state&lt;string | null&gt;(null);\n\n    onMount(async () =&gt; {\n        if (token) {\n            try {\n                user = await client.get_user();\n            } catch {\n                console.warn(\"Invalid token.\")\n                localStorage.removeItem('token');\n            }\n        }\n    });\n\n    async function handleLogin() {\n        const newToken = await client.login('admin'); // In a real app, we'd have a login form with username and password inputs.\n\n        localStorage.setItem('token', newToken);\n        window.location.reload(); // Reloading the page re-connects the client with the new auth token.\n    }\n\n    function handleLogout() {\n        localStorage.removeItem('token');\n        window.location.reload();\n    }\n&lt;/script&gt;\n\n{#if !token}\n    &lt;button onclick={handleLogin}&gt;Login&lt;/button&gt;\n{:else}\n    &lt;h1&gt;Welcome, {user}&lt;/h1&gt;\n    &lt;button onclick={handleLogout}&gt;Logout&lt;/button&gt;\n{/if}\n</code></pre>"}]}