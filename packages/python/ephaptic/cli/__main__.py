import sys, os, subprocess as sp
import json, re
import inspect, importlib, typing
from pathlib import Path

import typer

from pathlib import Path
from pydantic import TypeAdapter

from ephaptic import Ephaptic
from ephaptic.decorators import META_KEY

from typing import *

app = typer.Typer(help="Ephaptic CLI tool.")

IDENTIFIER_REGEX = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$')

LOG: List[str] = []

def log(*data):
    global LOG
    LOG.append(' '.join(data))

def clear_log():
    global LOG
    LOG = []

def key_name(key: str) -> str:
    if IDENTIFIER_REGEX.match(key): return key
    else: return json.dumps(key)

def validate(name: str) -> str:
    if IDENTIFIER_REGEX.match(name):
        safe = re.sub(r'[^a-zA-Z0-9_$]', '_', name)
        log(typer.style("[warning] '{name}' is not a valid identifier. sanitizing to '{safe}'", fg=typer.colors.YELLOW))
        return safe
    return name

def load_schema(input_path: str | Path):
    return json.loads(Path(input_path).read_text())
    # errors can be handled by typer

def load_ephaptic(import_name: str) -> Ephaptic:
    try:
        from dotenv import load_dotenv; load_dotenv()
    except: ...

    sys.path.insert(0, os.getcwd())

    if ":" not in import_name:
        log(typer.style(f"Warning: Import name did not specify client name. Defaulting to `client`.", fg=typer.colors.YELLOW))
        import_name += ":client" # default: expect client to be named `client` inside the file

    module_name, var_name = import_name.split(":", 1)

    try:
        log(typer.style(f"Attempting to import `{var_name}` from `{module_name}`..."))
        module = importlib.import_module(module_name)
    except ImportError as e:
        log(typer.style(f"Error: Can't import '{module_name}'.\n{e}", fg=typer.colors.RED))
        raise typer.Exit(1)
    
    try:
        instance = getattr(module, var_name)
    except AttributeError:
        log(typer.style(f"Error: Variable '{var_name}' not found in module '{module_name}'.", fg=typer.colors.RED))
        raise typer.Exit(1)
    
    if not isinstance(instance, Ephaptic):
        log(typer.style(f"Error: '{var_name}' is not an Ephaptic client. It is type: {type(instance)}", fg=typer.colors.RED))
        raise typer.Exit(1)
    
    return instance

def TS_resolve_type(schema: Dict[str, Any]) -> str:
    if not schema: return 'any'
    if schema.get('$ref'): return validate(schema['$ref'].split('/').pop() or 'any')
    if schema.get('enum'): return ' | '.join([json.dumps(val) for val in schema['enum']])
    if schema.get('anyOf'): return ' | '.join({TS_resolve_type(s) for s in schema['anyOf']})
    if schema.get('type') == 'array': return f"{TS_resolve_type(schema['items']) if schema.get('items') else 'any'}[]"
    if schema.get('type') in ('integer', 'number'): return 'number'
    if schema.get('type') == 'boolean': return 'boolean'
    if schema.get('type') == 'string': return 'string'
    if schema.get('type') == 'null': return 'null'

    if schema['type'] == 'object':
        if not schema['properties']: return 'Record<string, any>'
        props = [
            f"{key_name(key)}{'' if key in schema.get('required', []) else '?'}: {TS_resolve_type(prop_schema)}"
            for key, prop_schema in schema['properties'].items()
        ]
        return '{ ' + '; '.join(props) + ' }'
    
    return 'any'

def TS_generate(data: dict):
    lines: List[str] = []

    lines.extend([
        '/**',
        ' * Auto-generated by ephaptic',
        ' * Do not edit this file manually.',
        ' * */',
        '',
        'import { type EphapticClientBase } from "@ephaptic/client";',
        '',
        'export type EphapticQuery<TArgs extends any[], TReturn> = { queryKey: [string, ...TArgs]; queryFn: () => Promise<TReturn>; }'
        '',
    ])

    for name, schema in data.get('definitions', {}).items():
        name = validate(name)
        if schema['type'] == 'object':
            lines.append(f'export interface {name} {{')
            lines.extend([
                f"  {validate(prop_name)}{'' if prop_name in schema.get('required', []) else '?'}: {TS_resolve_type(prop_schema)};"
                for prop_name, prop_schema in schema['properties'].items()
            ])
            lines.append('}')
            lines.append('')
        else:
            lines.append(f'export type {name} = {TS_resolve_type(schema)};')
            lines.append('')

    lines.append('export interface EphapticEvents {')
    lines.extend([
        f" {validate(event_name)}: {TS_resolve_type(event_schema)};"
        for event_name, event_schema in data.get('events', {}).items()
    ])
    lines.append('}')
    lines.append('')

    lines.append('export interface EphapticService extends EphapticClientBase {')
    lines.append('')

    for method_name, method_data in data.get('methods', {}).items():
        args: List[str] = []

        args.extend([
            f"{validate(arg_name)}{'' if arg_name in method_data.get('required', []) else '?'}: {TS_resolve_type(arg_schema)}"
            for arg_name, arg_schema in method_data.get('args', {}).items()
        ])
        
        return_type = TS_resolve_type(method_data['return']) if method_data.get('return') else 'void'

        lines.append(f"  {validate(method_name)}({', '.join(args)}): Promise<{return_type}>;")

    lines.append('')
    lines.append('  queries: {')

    for method_name, method_data in data.get('methods', {}).items():
        args: List[str] = []

        args.extend([
            f"{validate(arg_name)}{'' if arg_name in method_data.get('required', {}) else '?'}: {TS_resolve_type(arg_schema)}"
            for arg_name, arg_schema in method_data.get('args', {}).items()
        ])

        arg_types = [TS_resolve_type(arg_schema) for arg_schema in method_data.get('args', {}).values()]
        
        return_type = TS_resolve_type(method_data['return']) if method_data.get('return') else 'void'

        lines.append(f"     {validate(method_name)}({', '.join(args)}): EphapticQuery<[{', '.join(arg_types)}], {return_type}>;")

    lines.append('  };')

    lines.append('')

    lines.append('    on<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;')
    lines.append('    off<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;')
    lines.append('    once<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;')

    lines.append('}');
    lines.append('');

    lines.extend([
        '/**',
        ' * Usage:',
        ' * import { connect } from "@ephaptic/client";',
        ' * import { type EphapticService } from "./ephaptic";',
        ' * ',
        ' * const client = connect(...) as unknown as EphapticService;',
        ' */',
    ])

    return lines

def KT_resolve_type(schema: Dict[str, Any]) -> str:
    if not schema: return 'Any?'
    if schema.get('$ref'): return validate(schema['$ref'].split('/').pop() or 'Any')
    if schema.get('enum') and len(schema['enum']) > 0:
        first = schema['enum'][0]
        if isinstance(first, str): return 'String'
        if isinstance(first, int): return 'Int'
        if isinstance(first, float): return 'Double'
        if isinstance(first, bool): return 'Boolean'
        return 'Any?'
    if schema.get('anyOf'):
        nonNull = [t for t in schema['anyOf'] if t['type'] != 'null']
        if len(nonNull) == 1:
            type = KT_resolve_type(nonNull[0])
            if not type.endswith('?'): type += '?'
            return type
        return 'Any?'
    if schema.get('type') == 'array': return f"List<{KT_resolve_type(schema['items']) if schema.get('items') else 'Any?'}>"
    if schema.get('type') == 'integer': return 'Long'
    if schema.get('type') == 'boolean': return 'Boolean'
    if schema.get('type') == 'string': return 'String'
    if schema.get('type') == 'null': return 'Nothing?'
    if schema.get('type') == 'object': return 'Map<String, Any?>'
    return 'Any?'

def KT_generate(data: dict, package_name: str):
    lines: List[str] = []

    lines.extend([
        '/**',
        ' * Auto-generated by ephaptic',
        ' * Do not edit this file manually.',
        ' * */',
        '',
        f'package {package_name}',
        '',
        'import com.squareup.moshi.JsonClass',
        'import com.ephaptic.android.EphapticClient',
        'import com.ephaptic.android.EphapticException',
        '',
    ])

    for name, schema in data.get('definitions', {}).items():
        name = validate(name)
        if schema['type'] == 'object':
            lines.append('@JsonClass(generateAdapter = true)')
            lines.append(f'data class {name}(')
            # i don't know if this is a good idea...
            lines.extend([
                f"  val {validate(prop_name)}: "
                f"{(kt := KT_resolve_type(prop_schema))}"
                f"{'?' if (prop_name not in schema.get('required', [])
                        or prop_schema.get('type') == 'null'
                        or any(t.get('type') == 'null' for t in prop_schema.get('anyOf', [])))
                and not kt.endswith('?') else ''}"
                f"{' = null' if (prop_name not in schema.get('required', [])
                                or prop_schema.get('type') == 'null'
                                or any(t.get('type') == 'null' for t in prop_schema.get('anyOf', [])))
                else ''},"
                for prop_name, prop_schema in schema['properties'].items()
            ])
            # ...but i like list comprehensions :)
            lines.append(')')
            lines.append('')
        else:
            lines.append(f'typealias {name} = {KT_resolve_type(schema)}')
            lines.append('')

    lines.append('sealed class EphapticEvent')
    lines.extend([
        f"  data class {validate(event_name)}(val data: {KT_resolve_type(event_schema)}): EphapticEvent()"
        for event_name, event_schema in data.get('events', {}).items()
    ])
    lines.append('}')
    lines.append('')

    lines.append('class EphapticService(private val client: EphapticClient) {')
    lines.append('')

    for method_name, method_data in data.get('methods', {}).items():
        args: List[str] = []
        params: List[str] = []

        for arg_name, arg_schema in method_data.get('args', {}).items():
            is_req = arg_name in method_data.get('required', [])
            kt_type = KT_resolve_type(arg_schema)

            if not is_req and not kt_type.endswith('?'): kt_type += '?'

            args.append(f"{validate(arg_name)}: {kt_type}")
            params.append(validate(arg_name))

        return_type = KT_resolve_type(method_data['return']) if method_data.get('return') else 'Any?'

        lines.append(f" suspend fun {validate(method_name)}({', '.join(args)}): {return_type} {{")
        lines.append(f'      return client.request<{return_type}>("{method_name}", {', '.join(params)})')
        lines.append('  }')
        lines.append('')

    lines.append('}')
    lines.append('')

    return lines

def create_schema(adapter: TypeAdapter, definitions: dict) -> dict:
    schema = adapter.json_schema(ref_template='#/definitions/{model}')

    if '$defs' in schema:
        definitions.update(schema.pop('$defs'))

    if schema.get('type') == 'object' and 'title' in schema:
        model = schema['title']
        definitions[model] = schema
        return { '$ref': f'#/definitions/{model}' }
    
    return schema

def run_subprocess():
    cmd = [sys.executable]
    cmd += [arg for arg in sys.argv if arg not in {'--watch', '-w'}]
    sp.run(cmd)

def calculate_language(lang: str, output: Path):
    if lang is None and str(output) != '-':
        if not output: raise ValueError("You must specify a language or an output path.")
        lang = os.path.splitext(output)[-1]
    
    map = {
        'kotlin': 'kt',
        'typescript': 'ts',
    }

    if lang in map: lang = map[lang]

    if output is None:
        match lang:
            case 'ts':
                output = Path('ephaptic.d.ts')
            case 'kt':
                output = Path('Ephaptic.kt')
            case _:
                output = Path('schema.json')

    return lang, output

class NothingToChange(Exception): ...

def generate_output(lang, schema_output, package_name, output: Path):
    content = None
    match lang:
        case 'json':
            content = json.dumps(schema_output, indent=2)
        case 'ts':
            content = '\n'.join(TS_generate(schema_output))
        case 'kt':
            content = '\n'.join(KT_generate(schema_output, package_name))

    if str(output) == '-':
        print(content)
        return

    if output.exists():
        if output.read_text() == content:
            return
        else:
            output.write_text(content)

    for line in LOG:
        typer.echo(line)

    clear_log()

    typer.secho(f"Schema generated to `{output}`.", fg=typer.colors.GREEN, bold=True)


@app.command()
def generate(
    client: str = typer.Argument('app:client', help="The import string for the Ephaptic client."),
    output: Path = typer.Option(None, '--output', '-o', help="Output path for the (default: schema.json / ephaptic.d.ts / Ephaptic.kt)."),
    watch: bool = typer.Option(False, '--watch', '-w', help="Watch for changes in `.py` files and regenerate schema file automatically."),
    lang: str = typer.Option(None, '--lang', '-l', help="Output language ('json', 'kotlin', 'kt', 'typescript', 'ts') (default: autodetected from output path)"),
    package_name: str = typer.Option('com.example.app', '--package-name', '-p', help="Package name (required for Kotlin)")
):
    lang, output = calculate_language(lang, output)

    if watch:
        import watchfiles
        
        cwd = os.getcwd()
        typer.secho(f"Watching for changes ({cwd})...",  fg=typer.colors.GREEN)

        run_subprocess()

        for changes in watchfiles.watch(cwd):
            if any(f.endswith('.py') for _, f in changes):
                typer.secho("Detected changes, regenerating...")
                run_subprocess()

        return

    ephaptic = load_ephaptic(client)

    schema_output = {
        "methods": {},
        "events": {},
        "definitions": {},
    }

    log(typer.style("--- Functions ---"))

    for name, func in ephaptic._exposed_functions.items():
        log(typer.style(f"  - {name}"))

        meta = getattr(func, META_KEY, {})

        hints = typing.get_type_hints(func)
        sig = inspect.signature(func)

        method_schema = {
            "args": {},
            "return": None,
            "required": [],
        }

        for param_name, param in sig.parameters.items():
            hint = hints.get(param_name, typing.Any)
            adapter = TypeAdapter(hint)

            method_schema["args"][param_name] = create_schema(
                adapter,
                schema_output["definitions"],
            )

            log(typer.style(f"    - {param_name}: {hint} = {param.default}"))

            if param.default == inspect.Parameter.empty:
                method_schema["required"].append(param_name)
            else:
                method_schema["args"][param_name]["default"] = str(param.default)

            

        return_hint = meta.get('response_model') or hints.get("return", typing.Any)
        if return_hint and return_hint is not type(None):
            adapter = TypeAdapter(return_hint)
            method_schema["return"] = create_schema(
                adapter,
                schema_output["definitions"],
            )

        schema_output["methods"][name] = method_schema

    log(typer.style("--- Events ---"))


    for name, model in ephaptic._exposed_events.items():
        log(typer.style(f"  - {name}"))
        adapter = TypeAdapter(model)

        schema_output["events"][name] = create_schema(
            adapter,
            schema_output["definitions"],
        )

    generate_output(lang, schema_output, package_name, output)

@app.command()
def from_schema(
    schema_path: Path = typer.Option('schema.json', help="Path to the schema file."),
    output: Path = typer.Option(None, '--output', '-o', help="Output path for the (default: ephaptic.d.ts / Ephaptic.kt)."),
    watch: bool = typer.Option(False, '--watch', '-w', help="Watch for changes in `.py` files and regenerate schema file automatically."),
    lang: str = typer.Option(None, '--lang', '-l', help="Output language ('kotlin', 'kt', 'typescript', 'ts') (default: autodetected from output path)"),
    package_name: str = typer.Option('com.example.app', '--package-name', '-p', help="Package name (required for Kotlin)")
):
    lang, output = calculate_language(lang, output)


    if watch:
        import watchfiles
        
        typer.secho(f"Watching for changes ({schema_path})...",  fg=typer.colors.GREEN)

        run_subprocess()

        for changes in watchfiles.watch(schema_path):
            if any(Path(f).name == schema_path.name for _, f in changes):
                typer.secho("Detected changes, regenerating...")
                run_subprocess()

        return
    
    schema_output = json.loads(schema_path.read_text())

    generate_output(lang, schema_output, package_name, output)

if __name__ == "__main__":
    app()