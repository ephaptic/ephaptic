#!/usr/bin/env node

import fs from 'fs';
import path from 'path';

const args = process.argv.slice(2);

function printUsage() {
    console.log(`
Usage: npx @ephaptic/type-gen <schema.json> [options]

Options:
  -o, --output <file>    Output file path (default: ephaptic.d.ts)
  --help                 Show this help message
`);
}

if (args.includes('--help')) {
    printUsage();
    process.exit(0);
}

let inputPath = args[0];
let outputPath = 'ephaptic.d.ts';

for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '-o' || arg === '--output') {
        if (i + 1 < args.length) {
            outputPath = args[i + 1];
            i++;
        } else {
            console.error("Error: --output flag requires a file path.");
            process.exit(1);
        }
    } else if (arg.startsWith('-') && arg !== '-') {
        console.error(`Error: Unknown option '${arg}'`);
        printUsage();
        process.exit(1);
    } else {
        if (!inputPath) inputPath = arg;
    }
}


if (!inputPath) {
    console.error("Error: Please provide an input schema file (or '-' to pipe through stdin).");
    printUsage();
    process.exit(1);
}

interface JsonSchema {
    type?: string | string[];
    $ref?: string;
    items?: JsonSchema;
    properties?: Record<string, JsonSchema>;
    required?: string[];
    anyOf?: JsonSchema[];
    allOf?: JsonSchema[];
    oneOf?: JsonSchema[];
    title?: string;
    enum?: any[];
}

interface EphapticSchema {
    methods: Record<string, { args: Record<string, JsonSchema>, return: JsonSchema | null }>;
    definitions: Record<string, JsonSchema>;
}

function keyName(key: string): string {
    if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) return key;
    else return JSON.stringify(key);
}

function validate(name: string): string {
    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
        console.warn(`[warning] '${name}' is not a valid TypeScript identifier. sanitizing...`);
        return name.replace(/[^a-zA-Z0-9_$]/g, '_');
    }
    return name;
}

function resolveType(schema: JsonSchema): string {
    if (!schema) return 'any';

    if (schema.$ref) {
        return validate(schema.$ref.split('/').pop() || 'any');
    }

    if (schema.enum) {
        return schema.enum?.map(val => JSON.stringify(val)).join(` | `);
    }

    if (schema.anyOf) {
        const types = schema.anyOf.map(resolveType);
        const unique = Array.from(new Set(types));
        return unique.join(' | ');
    }

    if (schema.type === 'array') {
        const items = schema.items ? resolveType(schema.items) : 'any';
        return `${items}[]`;
    }

    if (schema.type === 'integer' || schema.type === 'number') return 'number';
    if (schema.type === 'boolean') return 'boolean';
    if (schema.type === 'string') return 'string';
    if (schema.type === 'null') return 'null';


    if (schema.type === 'object') {
        if (!schema.properties) return 'Record<string, any>';
        
        const props = Object.entries(schema.properties).map(([key, propSchema]) => {
            return `${keyName(key)}${schema.required?.includes(key) ? '' : '?'}: ${resolveType(propSchema)}`;
        });
        return `{ ${props.join('; ')} }`;
    }

    return 'any';
}

function generate() {
    let raw: string;

    if (inputPath === '-') {
        raw = fs.readFileSync(0, 'utf-8');
    } else {
        const fullPath = path.resolve(process.cwd(), inputPath);

        if (!fs.existsSync(fullPath)) {
            console.error(`Error: File not found: ${fullPath}`);
            process.exit(1);
        }

        raw = fs.readFileSync(fullPath, 'utf-8');
    }

    const data: EphapticSchema = JSON.parse(raw);

    const lines: string[] = [];

    lines.push(...[
        `/**`,
        ` * Auto-generated by @ephaptic/type-gen`,
        ` * Do not edit this file manually.`,
        ` * */`,
        ``,
        `import { type EphapticClientBase } from '@ephaptic/client';`,
        ``,
        `// --- Interfaces ---`,
        ``,
    ])

    for (let [name, schema] of Object.entries(data.definitions)) {
        name = validate(name);
        if (schema.type === 'object') {
            lines.push(`export interface ${name} {`);
            if (schema.properties) {
                for (const [propName, propSchema] of Object.entries(schema.properties)) {
                    lines.push(`    ${keyName(propName)}${schema?.required?.includes(propName) ? '' : '?'}: ${resolveType(propSchema)};`);
                }
            }
            lines.push(`}`);
            lines.push(``);
        } else {
            lines.push(`export type ${name} = ${resolveType(schema)};`);
            lines.push(``);
        }
    }

    lines.push(`// --- Client Definition ---`);
    lines.push(``);
    lines.push(`export interface EphapticService extends EphapticClientBase {`);

    for (const [methodName, methodData] of Object.entries(data.methods)) {
        const args: string[] = [];

        for (const [argName, argSchema] of Object.entries(methodData.args)) {
            args.push(`${validate(argName)}: ${resolveType(argSchema)}`);
        }

        const returnType = methodData.return ? resolveType(methodData.return) : 'void';

        lines.push(`    ${validate(methodName)}(${args.join(', ')}): Promise<${returnType}>;`);
    }

    lines.push(`}`);
    lines.push(``);

    lines.push(...[
        `/**`,
        ` * Usage:`,
        ` * import { connect } from '@ephaptic/client';`,
        ` * import { type EphapticService } from './ephaptic';`,
        ` * `,
        ` * const client = connect(...) as unknown as EphapticService;`,
        ` */`,
    ]);

    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`TypeScript definitions generated at: '${outputPath}'.`)
}

generate();