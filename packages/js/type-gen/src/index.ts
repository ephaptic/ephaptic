#!/usr/bin/env node

import fs from 'fs';
import path, { parse } from 'path';

interface Options {
    input: string;
    output: string;
    lang: 'ts' | 'kt';
    packageName?: string;
    watch: boolean;
}

const args = process.argv.slice(2);

function printUsage() {
    console.log(`
Usage: npx @ephaptic/type-gen <schema.json> [options]

Options:
  -o, --output <file>    Output file path (default: ephaptic.d.ts)
  -w, --watch            Watch input files for changes
  -l, --lang <lang>      Language: 'ts' (typescript) or 'kt' (kotlin). Default: ts
  -p, --package <name>   Package name (required for Kotlin, e.g. "com.my.app")
  --help                 Show this help message
`);
}

function parseArgs(): Options {
    const args = process.argv.slice(2);
    const opts: Options = {
        input: '',
        output: '',
        lang: 'ts',
        packageName: 'com.my.app',
        watch: false
    };

    if (args.includes('--help')) {
        printUsage();
        process.exit(0);
    }

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        switch (arg) {
            case '-o':
            case '--output':
                opts.output = args[++i];
                break;
            case '-w':
            case '--watch':
                opts.watch = true;
                break;
            case '-l':
            case '--lang':
                const l = args[++i]?.toLowerCase();
                if (l === 'kt' || l === 'kotlin') opts.lang = 'kt';
                else if (l === 'ts' || l === 'typescript') opts.lang = 'ts';
                else {
                    console.error(`Error: Unknown language '${l}'. Supported: ts, kt`);
                    process.exit(1);
                }
                break;
            case '-p':
            case '--package':
                opts.packageName = args[++i];
                break;
            default:
                if (arg.startsWith('-')) {
                    console.error(`Error: Unknown option '${arg}'`);
                    printUsage();
                    process.exit(1);
                }
                if (!opts.input) opts.input = arg;
                break;
        }
    }

    if (!opts.input) {
        console.error("Error: Input schema file is required.");
        process.exit(1);
    }

    if (!opts.output) {
        opts.output = opts.lang === 'kt' ? 'EphapticGenerated.kt' : 'ephaptic.d.ts';
    }

    return opts;
}

interface JsonSchema {
    type?: string | string[];
    $ref?: string;
    items?: JsonSchema;
    properties?: Record<string, JsonSchema>;
    required?: string[];
    default?: string;
    anyOf?: JsonSchema[];
    allOf?: JsonSchema[];
    oneOf?: JsonSchema[];
    title?: string;
    enum?: any[];
}

interface EphapticSchema {
    methods: Record<string, { args: Record<string, JsonSchema>, return: JsonSchema | null, required: string[] }>;
    events?: Record<string, JsonSchema>;
    definitions: Record<string, JsonSchema>;
}

function keyName(key: string): string {
    if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) return key;
    else return JSON.stringify(key);
}

function validate(name: string): string {
    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
        const safe = name.replace(/[^a-zA-Z0-9_$]/g, '_');
        console.warn(`[warning] '${name}' is not a valid identifier. sanitizing to '${safe}'`);
        return safe;
    }
    return name;
}

function loadSchema(inputPath: string): EphapticSchema | null {
    try {
        const raw = fs.readFileSync(inputPath === '-' ? 0 : path.resolve(process.cwd(), inputPath), 'utf-8');
        return JSON.parse(raw);
    } catch (err) {
        console.error("Error parsing schema:", err);
        return null;
    }
}

function TS_resolveType(schema: JsonSchema): string {
    if (!schema) return 'any';
    if (schema.$ref) return validate(schema.$ref.split('/').pop() || 'any');
    if (schema.enum) return schema.enum?.map(val => JSON.stringify(val)).join(` | `);    
    if (schema.anyOf) return Array.from(new Set(schema.anyOf.map(TS_resolveType))).join(' | ');
    if (schema.type === 'array') return `${schema.items ? TS_resolveType(schema.items) : 'any'}[]`;
    if (schema.type === 'integer' || schema.type === 'number') return 'number';
    if (schema.type === 'boolean') return 'boolean';
    if (schema.type === 'string') return 'string';
    if (schema.type === 'null') return 'null';


    if (schema.type === 'object') {
        if (!schema.properties) return 'Record<string, any>';
        
        const props = Object.entries(schema.properties).map(([key, propSchema]) => {
            return `${keyName(key)}${schema.required?.includes(key) ? '' : '?'}: ${TS_resolveType(propSchema)}`;
        });
        return `{ ${props.join('; ')} }`;
    }

    return 'any';
}

function TS_generate(data: EphapticSchema, opts: Options) {
    const lines: string[] = [];

    lines.push(...[
        `/**`,
        ` * Auto-generated by @ephaptic/type-gen`,
        ` * Do not edit this file manually.`,
        ` * */`,
        ``,
        `import { type EphapticClientBase } from '@ephaptic/client';`,
        ``,
        `export type EphapticQuery<TArgs extends any[], TReturn> = { queryKey: [string, ...TArgs]; queryFn: () => Promise<TReturn>; }`,
        ``,
        `// --- Interfaces ---`,
        ``,
    ]);

    for (let [name, schema] of Object.entries(data.definitions)) {
        name = validate(name);
        if (schema.type === 'object') {
            lines.push(`export interface ${name} {`);
            Object.entries(schema.properties ?? {}).forEach(([propName, propSchema], index) => {
                lines.push(`    ${keyName(propName)}${schema?.required?.includes(propName) ? '' : '?'}: ${TS_resolveType(propSchema)};`);
            });
            lines.push(`}`);
            lines.push(``);
        } else {
            lines.push(`export type ${name} = ${TS_resolveType(schema)};`);
            lines.push(``);
        }
    }

    lines.push(`export interface EphapticEvents {`);
    for (const [eventName, eventSchema] of Object.entries(data.events ?? {})) {
        lines.push(`    ${validate(eventName)}: ${TS_resolveType(eventSchema)};`);
    }
    lines.push(`}`);
    lines.push(``);

    lines.push(`// --- Client Definition ---`);
    lines.push(``);
    lines.push(`export interface EphapticService extends EphapticClientBase {`);

    for (const [methodName, methodData] of Object.entries(data.methods)) {
        const args: string[] = [];

        for (const [argName, argSchema] of Object.entries(methodData.args)) {
            const sep = methodData.required.includes(argName) ? ':' : '?:';
            args.push(`${validate(argName)}${sep} ${TS_resolveType(argSchema)}`);
        }

        const returnType = methodData.return ? TS_resolveType(methodData.return) : 'void';

        lines.push(`    ${validate(methodName)}(${args.join(', ')}): Promise<${returnType}>;`);
    }

    lines.push(``);
    lines.push(`    queries: {`);

    if (data.methods) {
        for (const [methodName, methodData] of Object.entries(data.methods)) {
            const args: string[] = [];
            const argTypes: string[] = [];

            if (methodData.args) {
                for (const [argName, argSchema] of Object.entries(methodData.args)) {
                    const sep = methodData.required.includes(argName) ? ':' : '?:';
                    args.push(`${validate(argName)}${sep} ${TS_resolveType(argSchema)}`);
                    argTypes.push(TS_resolveType(argSchema));
                }
            }

            const returnType = methodData.return ? TS_resolveType(methodData.return) : 'void';

            lines.push(`        ${validate(methodName)}(${args.join(', ')}): EphapticQuery<[${argTypes.join(', ')}], ${returnType}>;`);
        }
    }

    lines.push(`    };`)

    lines.push(``);

    lines.push(`    on<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;`);
    lines.push(`    off<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;`);
    lines.push(`    once<K extends keyof EphapticEvents>(event: K, callback: (data: EphapticEvents[K]) => void): void;`);

    lines.push(`}`);
    lines.push(``);

    lines.push(...[
        `/**`,
        ` * Usage:`,
        ` * import { connect } from '@ephaptic/client';`,
        ` * import { type EphapticService } from './ephaptic';`,
        ` * `,
        ` * const client = connect(...) as unknown as EphapticService;`,
        ` */`,
    ]);

    return lines
}

function KT_resolveType(schema: JsonSchema): string {
    if (!schema) return 'Any?';
    if (schema.$ref) return validate(schema.$ref.split('/').pop() || 'Any');
    if (schema.enum && schema.enum.length > 0) {
        const first = schema.enum[0];
        if (typeof first === 'string') return 'String';
        if (typeof first === 'number') return Number.isInteger(first) ? 'Int' : 'Double';
        if (typeof first === 'boolean') return 'Boolean';
        return 'Any?';
    }
    if (schema.anyOf) {
        const nonNull = schema.anyOf.filter(t => t.type !== 'null');
        if (nonNull.length === 1) {
            let type = KT_resolveType(nonNull[0]);
            if (!type.endsWith('?')) type += '?';
            return type;
        }       
        return 'Any?';
    }
    if (schema.type === 'array') return `List<${schema.items ? KT_resolveType(schema.items) : 'Any?'}>`;
    if (schema.type === 'integer') return 'Long';
    if (schema.type === 'number') return 'Double';
    if (schema.type === 'boolean') return 'Boolean';
    if (schema.type === 'string') return 'String';
    if (schema.type === 'null') return 'Nothing?';
    if (schema.type === 'object') return 'Map<String, Any?>';
    return 'Any?';
}

function KT_generate(data: EphapticSchema, opts: Options) {
    const lines: string[] = [];

    lines.push(...[
        `/**`,
        ` * Auto-generated by @ephaptic/type-gen`,
        ` * Do not edit this file manually.`,
        ` * */`,
        ``,
        `package ${opts.packageName}`,
        ``,
        `import com.squareup.moshi.JsonClass`,
        `import com.ephaptic.android.EphapticClient`,
        `import com.ephaptic.android.EphapticException`,
        ``,
    ]);

    for (let [name, schema] of Object.entries(data.definitions)) {
        name = validate(name);
        if (schema.type === 'object') {
            lines.push(`@JsonClass(generateAdapter = true)`);
            lines.push(`data class ${name}(`);
            Object.entries(schema.properties ?? {}).forEach(([propName, propSchema], index) => {
                const isReq = schema.required?.includes(propName);
                const isNullable = !isReq || propSchema.type === 'null' || propSchema.anyOf?.some(t => t.type === 'null');
                let ktType = KT_resolveType(propSchema);
                if (isNullable && !ktType.endsWith('?')) ktType += '?';
                const suffix = index < Object.entries(schema.properties??{}).length - 1 ? ',' : '';
                lines.push(`    val ${validate(propName)}: ${ktType}${isNullable ? ' = null' : ''}${suffix}`);
            });
            lines.push(`)`);
            lines.push(``);
        } else {
            lines.push(`typealias ${name} = ${KT_resolveType(schema)}`);
            lines.push(``);
        }
    }

    lines.push(`sealed class EphapticEvent {`);
    for (const [eventName, eventSchema] of Object.entries(data.events ?? {})) {
        lines.push(`    data class ${validate(eventName)}(val data: ${KT_resolveType(eventSchema)}): EphapticEvent()`);
    }
    lines.push(`}`);
    lines.push(``);

    lines.push(`class EphapticService(private val client: EphapticClient) {`);
    lines.push(``);

    for (const [methodName, methodData] of Object.entries(data.methods)) {
        const args: string[] = [];
        const params: string[] = [];

        for (const [argName, argSchema] of Object.entries(methodData.args)) {
            const isReq = methodData.required.includes(argName);
            let ktType = KT_resolveType(argSchema);
            if (!isReq && !ktType.endsWith('?')) ktType += '?';
            args.push(`${validate(argName)}: ${ktType}`);
            params.push(validate(argName));
        }

        const returnType = methodData.return ? KT_resolveType(methodData.return) : 'Any?';
        const funcName = validate(methodName);

        lines.push(`    suspend fun ${funcName}(${args.join(', ')}): ${returnType} {`);
        lines.push(`        return client.request<${returnType}>("${methodName}", ${params.join(', ')})`);
        lines.push(`    }`);
        lines.push(``);
    }

    lines.push(`}`);
    lines.push(``);

    return lines
}

function run() {
    const opts = parseArgs();

    if (opts.watch && opts.input === '-') {
        console.error("Error: Cannot use --watch when input is stdin.");
        process.exit(1);
    }

    const thingy = () => {
        const data = loadSchema(opts.input);
        if (!data) return;

        let lines: string[] = opts.lang === 'ts' ? TS_generate(data, opts) : KT_generate(data, opts);

        fs.writeFileSync(opts.output, lines.join('\n'));
        console.log(`[${new Date().toLocaleTimeString()}] generated ${opts.lang} types at ${opts.output}`);
    };

    thingy();

    if (opts.watch) {
        console.log(`watching ${opts.input} for changes...`);
        let wait: NodeJS.Timeout | null = null;
        const watchPath = path.resolve(process.cwd(), opts.input);

        fs.watch(watchPath, (event, filename) => {
            if (filename && !wait) {
                wait = setTimeout(() => {
                    wait = null;
                    console.log(`Change detected, regenerating types...`);
                    thingy();
                }, 100);
            }
        });

        setInterval(() => {}, 36 * Math.pow(10, 5));
    }
}

run();